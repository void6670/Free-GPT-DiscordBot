/**
 * @name ranges-apply
 * @fileoverview Take an array of string index ranges, delete/replace the string according to them
 * @version 7.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-apply/}
 */

"use strict";var rangesApply=(()=>{var c=Object.defineProperty;var _=Object.getOwnPropertyDescriptor;var N=Object.getOwnPropertyNames,w=Object.getOwnPropertySymbols;var v=Object.prototype.hasOwnProperty,j=Object.prototype.propertyIsEnumerable;var T=(s,n,o)=>n in s?c(s,n,{enumerable:!0,configurable:!0,writable:!0,value:o}):s[n]=o,y=(s,n)=>{for(var o in n||(n={}))v.call(n,o)&&T(s,o,n[o]);if(w)for(var o of w(n))j.call(n,o)&&T(s,o,n[o]);return s};var D=(s,n)=>{for(var o in n)c(s,o,{get:n[o],enumerable:!0})},R=(s,n,o,t)=>{if(n&&typeof n=="object"||typeof n=="function")for(let l of N(n))!v.call(s,l)&&l!==o&&c(s,l,{get:()=>n[l],enumerable:!(t=_(n,l))||t.enumerable});return s};var S=s=>R(c({},"__esModule",{value:!0}),s);var F={};D(F,{rApply:()=>M,version:()=>A});var H={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function d(s,n){if(!Array.isArray(s)||!s.length)return s;let o=y(y({},H),n),t,l;if(o.strictlyTwoElementsInRangeArrays&&!s.every((a,p)=>!Array.isArray(a)||a.length!==2?(t=p,l=a.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${t}th range (${JSON.stringify(s[t],null,4)}) has not two but ${l} elements!`);if(!s.every((a,p)=>!Array.isArray(a)||!Number.isInteger(a[0])||a[0]<0||!Number.isInteger(a[1])||a[1]<0?(t=p,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${t}th range (${JSON.stringify(s[t],null,4)}) does not consist of only natural numbers!`);let r=s.length**2,u=0;return Array.from(s).sort((a,p)=>(o.progressFn&&(u+=1,o.progressFn(Math.floor(u*100/r))),a[0]===p[0]?a[1]<p[1]?-1:a[1]>p[1]?1:0:a[0]<p[0]?-1:1))}var b={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function $(s,n){function o(e){return!!e&&typeof e=="object"&&!Array.isArray(e)}if(!Array.isArray(s)||!s.length)return null;let t;if(n)if(o(n)){if(t=y(y({},b),n),t.progressFn&&o(t.progressFn)&&!Object.keys(t.progressFn).length)t.progressFn=null;else if(t.progressFn&&typeof t.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof t.progressFn}", equal to ${JSON.stringify(t.progressFn,null,4)}`);if(![1,2,"1","2"].includes(t.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof t.mergeType}", equal to ${JSON.stringify(t.mergeType,null,4)}`);if(typeof t.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof t.joinRangesThatTouchEdges}", equal to ${JSON.stringify(t.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(n,null,4)} (type ${typeof n})`);else t=y({},b);let l=s.filter(e=>Array.isArray(e)).map(e=>[...e]).filter(e=>e[2]!==void 0||e[0]!==e[1]),r,u,a;t.progressFn?r=d(l,{progressFn:e=>{a=Math.floor(e/5),a!==u&&(u=a,t.progressFn(a))}}):r=d(l);let p=r.length-1;for(let e=p;e>0;e--)t.progressFn&&(a=Math.floor((1-e/p)*78)+21,a!==u&&a>u&&(u=a,t.progressFn(a))),(r[e][0]<=r[e-1][0]||!t.joinRangesThatTouchEdges&&r[e][0]<r[e-1][1]||t.joinRangesThatTouchEdges&&r[e][0]<=r[e-1][1])&&(r[e-1][0]=Math.min(r[e][0],r[e-1][0]),r[e-1][1]=Math.max(r[e][1],r[e-1][1]),r[e][2]!==void 0&&(r[e-1][0]>=r[e][0]||r[e-1][1]<=r[e][1])&&r[e-1][2]!==null&&(r[e][2]===null&&r[e-1][2]!==null?r[e-1][2]=null:r[e-1][2]!=null?+t.mergeType==2&&r[e-1][0]===r[e][0]?r[e-1][2]=r[e][2]:r[e-1][2]+=r[e][2]:r[e-1][2]=r[e][2]),r.splice(e,1),e=r.length);return r.length?r:null}var J=!0,h="Invariant failed";function I(s,n){if(!s){if(J)throw new Error(h);var o=typeof n=="function"?n():n,t=o?"".concat(h,": ").concat(o):h;throw new Error(t)}}var E="7.0.10";var A=E;function M(s,n,o){let t=0,l=0;if(arguments.length===0)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(typeof s!="string")throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof s}, equal to: ${JSON.stringify(s,null,4)}`);if(n&&!Array.isArray(n))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof n}, equal to: ${JSON.stringify(n,null,4)}`);if(o&&typeof o!="function")throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof o}, equal to: ${JSON.stringify(o,null,4)}`);if(!(n!=null&&n.filter(i=>i).length))return s;let r;Array.isArray(n)&&Number.isInteger(n[0])&&Number.isInteger(n[1])?r=[Array.from(n)]:r=Array.from(n);let u=r.length,a=0;r.filter(i=>i).forEach((i,g)=>{if(o&&(t=Math.floor(a/u*10),t!==l&&(l=t,o(t))),!Array.isArray(i))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${g}th element not an array: ${JSON.stringify(i,null,4)}, which is ${typeof i}`);if(!Number.isInteger(i[0])){if(!Number.isInteger(+i[0])||+i[0]<0)throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${g}th element, array ${JSON.stringify(i,null,0)}. Its first element is not an integer, string index, but ${typeof i[0]}, equal to: ${JSON.stringify(i[0],null,4)}.`);r[g][0]=+r[g][0]}if(!Number.isInteger(i[1])){if(!Number.isInteger(+i[1])||+i[1]<0)throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${g}th element, array ${JSON.stringify(i,null,0)}. Its second element is not an integer, string index, but ${typeof i[1]}, equal to: ${JSON.stringify(i[1],null,4)}.`);r[g][1]=+r[g][1]}a+=1});let p=$(r,{progressFn:i=>{o&&(t=10+Math.floor(i/10),t!==l&&(l=t,o(t)))}});I(p);let e=p.length;if(e>0){let i=s.slice(p[e-1][1]);s=p.reduce((g,q,f,m)=>{o&&(t=20+Math.floor(f/e*80),t!==l&&(l=t,o(t)));let O=f===0?0:m[f-1][1],x=m[f][0];return`${g}${s.slice(O,x)}${m[f][2]||""}`},""),s+=i}return s}return S(F);})();
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 6.0.8
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 9.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */
